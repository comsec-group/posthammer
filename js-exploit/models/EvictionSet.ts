class EvictionSet {
  addrs: number[];
  iter: number[];
  iter32: number[];
  iterMask: number;
  laneSize: number;
  colors: number[][];

  readonly sizeWhenMinimal: number;

  private baseline: number;
  private partner: EvictionSet;
  private warm: boolean;

  boundary: number;

  constructor(sizeWhenMinimal: number) {
    this.addrs = [];
    this.iter = [];
    this.iter32 = [];
    this.iterMask = 0;
    this.laneSize = 0;
    this.colors = [];

    this.sizeWhenMinimal = sizeWhenMinimal;

    this.baseline = 0;
    this.partner = null;
    this.warm = false;
  }

  /* Simply loop over the set */
  private evict(): void {
    for (let i = 0; i < this.sizeWhenMinimal; i++) {
      dummy[0] ^= buf8[this.addrs[i]];
    }
  }

  install(dataPattern: number) {
    assert(this.iter32.length);

    for (let i = 0; i < this.iter32.length; i++) {
      assert(typeof buf32[this.iter32[i]] === "number");
      assert(
        !buf32[this.iter32[i]] ||
          buf32[this.iter32[i]] === dataPattern ||
          (buf32[this.iter32[i]] === dataPattern) ^ 0xffffffff,
      );
      buf32[this.iter32[i]] = this.iter32[(i + 1) % this.iter32.length];
    }
  }

  installMB(validDataPatterns: number[], nestedBuffer: number[][]): boolean {
    if (!this.iter32.length) return false;

    for (let i = 0; i < this.iter32.length; i++) {
      assert(this.iter32[i] != 0xffffffff);

      if (this.iter32[i] === 0) return false;

      let x = this.iter32[i] >>> 14;
      let y = this.iter32[i] & 0x3fff;

      let old = nestedBuffer[x][y];

      assert(typeof old === "number");

      /* Can't check this... Hmm */
      /*
       * Ideally I'd do something like...
       * assert(!old || validDataPatterns.includes(old));
       */

      let packed = this.iter32[(i + 1) % this.iter32.length];

      nestedBuffer[x][y] = packed;
    }

    return true;
  }

  clearMB(dataPattern: number, nestedBuffer: number[][]) {
    assert(this.iter32.length);

    for (let i = 0; i < this.iter32.length; i++) {
      assert(this.iter32[i] != 0xffffffff);

      let x = this.iter32[i] >>> 14;
      let y = this.iter32[i] & 0x3fff;

      nestedBuffer[x][y] = dataPattern;
    }
  }

  get bufIdxs(): number[] {
    return this.iter32.map((packed) => packed >>> 14);
  }

  get bufIdxsIndirect(): number[] {
    return this.addrs.map(
      (addr) => addr[0] * bufsPerSlab + slabOffsetToBuf(addr[3]),
    );
  }

  install2(dataPattern: number) {
    assert(this.iter32.length);
    assert(this.iter32.length % 2 === 0);

    for (let i = 0; i < this.iter32.length; i += 2) {
      assert(typeof buf32[this.iter32[i]] === "number");
      assert(
        !buf32[this.iter32[i]] ||
          buf32[this.iter32[i]] === dataPattern ||
          (buf32[this.iter32[i]] === dataPattern) ^ 0xffffffff,
      );
      buf32[this.iter32[i]] = this.iter32[(i + 2) % this.iter32.length];
      buf32[this.iter32[i + 1]] = this.iter32[(i + 3) % this.iter32.length];
    }
  }

  setColor(c: number) {
    assert(c < this.colors.length);
    this.addrs = this.colors[c];
  }

  uninstall() {
    assert(this.iter32.length);

    for (let i = 0; i < this.iter32.length; i++) {
      assert(typeof buf32[this.iter32[i]] === "number");
      /* Why did this fail once?! Unlucky overlapping double pattern maybe */
      assert(buf32[this.iter32[i]]);
      buf32[this.iter32[i]] = 0;
    }
  }

  get sets(): EvictionSet[] {
    assert(this.partner);
    return [this, this.partner];
  }

  get start(): number {
    assert(this.iter32.length);
    return this.iter32[0];
  }

  pair(set: EvictionSet) {
    if (this.partner === null) {
      this.partner = set;
      set.pair(this);
    } else {
      assert(this.partner == set);
    }
  }

  printIterable(hugePageAtPages: number[], li: LLCInfo, bs: BankStats) {
    assert(this.partner);
    assert(this.iter.length % this.laneSize === 0);

    const lanes: number = this.iter.length / this.laneSize;

    let xs: number[] = this.iter;
    let ys: number[] = this.partner.iter;

    const shifted = (zs) => {
      return zs.map((x) => x >> 6);
    };

    const xss = shifted(xs);
    const yss = shifted(ys);

    print(
      "ln|gli|li|m|         b| h |bk|row|set| ix|---|m|         b| h |bk|row|set| ix|",
    );

    for (let l = 0; l < lanes; l++) {
      for (let i = 0; i < this.laneSize; i++) {
        if (l && !i) {
          print("");
        }

        let k = l * this.laneSize + i;
        let x = btop(xs[k], hugePageAtPages);
        let y = btop(ys[k], hugePageAtPages);
        let miss = this.iterMask & (1 << i) ? "*" : " ";

        print(
          __pfst(l, 0, 2),
          __pfst(k, 0, 3),
          __pfst(i, 0, 2),
          miss,
          __pfst(xs[k], 0, 10),
          __pfst(x.h, 0, 3),
          __pfst(bs.ptoba(x.p), 0, 2),
          __pfst(bs.ptoro(x.p), 0, 3),
          __pfst(li.ptose(x.p), 0, 3),
          __pfst(xss.indexOf(xss[k]), 0, 3),
          "   ",
          miss,
          __pfst(ys[k], 0, 10),
          __pfst(y.h, 0, 3),
          __pfst(bs.ptoba(y.p), 0, 2),
          __pfst(bs.ptoro(y.p), 0, 3),
          __pfst(li.ptose(y.p), 0, 3),
          __pfst(yss.indexOf(yss[k]), 0, 3),
        );
      }
    }
  }

  newIterableMB(
    mask: number,
    laneSize: number,
    nonUniformity: number,
    matches: number[],
    bs: bankStats,
  ) {
    const intSizeInBytes: number = 4;

    /* A, B, C or just A, B */
    const uniqueLanes = nonUniformity ? MAX_UNIQUE_LANES : MAX_UNIQUE_LANES - 1;

    assert(nonUniformity >= 0 && nonUniformity <= 3);
    assert(uniqueLanes * laneSize <= this.addrs.length);

    /* In total, e.g. A, B, A, B, A, B, A, C */
    let lanes: number = 2 + 2 * nonUniformity;
    let size: number = laneSize * lanes;

    this.iter = Array(size);
    this.iterMask = mask;
    this.laneSize = laneSize;

    for (let l = 0; l < lanes; l++) {
      for (let j = 0; j < laneSize; j++) {
        let i = l * laneSize + j;

        if (nonUniformity && l == lanes - 1) {
          this.iter[i] = [...this.addrs[j + 2 * laneSize]]; /* C */
        } else if (l % 2 == 1) {
          this.iter[i] = [...this.addrs[j + laneSize]]; /* B */
        } else {
          this.iter[i] = [...this.addrs[j]]; /* A */
        }

        assert(this.iter[i].length === 4);

        let hit: boolean = false;

        /* Hit in a non-first lane: always A! */
        if (l && !(mask & (1 << j))) {
          this.iter[i] = [...this.addrs[j]];
          hit = true;
        }

        const [h, pfn, px, p] = this.iter[i];

        if (h === -1) {
          this.iter32 = [];
          return;
        }

        print(
          `lane ${l}, ${hit ? "\tH" : "M"}, j ${j}, h ${h}, bk ${bs.ptoba((pfn << 12) + p)}, rw ${bs.ptoro((pfn << 12) + p)}, p ${p}, pfn ${pfn}`,
        );

        /* Update @px and @p */
        this.iter[i][2] += l * intSizeInBytes;
        this.iter[i][3] += l * intSizeInBytes;

        assert(((this.iter[i][3] - l * intSizeInBytes) & 0x3f) === 0);

        assert(this.iter[i].length === 4);
      }

      print("");
    }

    /* Special iter: a 32-bit value that identifies what should be accessed */
    this.iter32 = this.iter.map((addr, i) => {
      const [h, pfn, px, p] = addr;

      if (h === -1) return 0;

      let y = p % bufSize;
      let x = h * bufsPerSlab + slabOffsetToBuf(p);

      assert((y & 0xffff0000) === 0);
      assert((y & 0x3) === 0);
      assert((x & ~0x3ffff) === 0);

      let packed = ((x << 14) ^ (y >>> 2)) >>> 0;

      return packed;
    });
  }

  /*
   * nonUniformity: 0, 1, 2, 3
   */
  newIterable(mask: number, laneSize: number, nonUniformity: number) {
    const intSizeInBytes: number = 4;

    /* A, B, C or just A, B */
    const uniqueLanes = nonUniformity ? MAX_UNIQUE_LANES : MAX_UNIQUE_LANES - 1;

    assert(nonUniformity >= 0 && nonUniformity <= 3);
    assert(uniqueLanes * laneSize <= this.addrs.length);

    /* In total, e.g. A, B, A, B, A, B, A, C */
    let lanes: number = 2 + 2 * nonUniformity;
    let size: number = laneSize * lanes;

    this.iter = Array(size).fill(0);
    this.iterMask = mask;
    this.laneSize = laneSize;

    for (let l = 0; l < lanes; l++) {
      for (let j = 0; j < laneSize; j++) {
        let i = l * laneSize + j;

        if (nonUniformity && l == lanes - 1) {
          this.iter[i] = this.addrs[j + 2 * laneSize]; /* C */
        } else if (l % 2 == 1) {
          this.iter[i] = this.addrs[j + laneSize]; /* B */
        } else {
          this.iter[i] = this.addrs[j]; /* A */
        }

        /* Hit in a non-first lane: always A! */
        if (l && !(mask & (1 << j))) {
          this.iter[i] = this.addrs[j];
        }

        this.iter[i] += l * intSizeInBytes;
      }
    }

    this.iter32 = this.iter.map((x) => {
      assert((x & 0x3) === 0);
      assert(!(~buf32Bounds & (x >> 2)));
      return x >> 2;
    });
  }

  public evictsNested(nestedBuffer: number[][]) {
    const reps: number = 8;

    assert(this.addrs.length > this.sizeWhenMinimal);
    assert(bufsPerSlab === 18);

    const slabIdxs: number[] = this.addrs.map((x) => x[0]);
    const ps: number[] = this.addrs.map((x) => x[3]);

    const bufIdxs: number[] = ps.map(
      (p, i) => slabIdxs[i] * bufsPerSlab + slabOffsetToBuf(p),
    );

    bufIdxs.map((i) => assert(i >= 0 && i < nestedBuffer.length));

    const bs: number[] = ps.map((p) => p % bufSize);

    for (const [i, base] of [0, this.sizeWhenMinimal].entries()) {
      let times: number[] = Array(reps).fill(0);
      let result: number = 0;

      if (!i && this.baseline) continue;

      /* We need to get this code optimized first */
      for (let r = 0; r < reps; r++) {
        var before: number = performance.now();

        for (let a = 0; a < 4 * 10 ** 3; a++) {
          for (let j = 0; j < this.sizeWhenMinimal; j++) {
            dummy[0] ^= nestedBuffer[bufIdxs[j]][bs[j]];
          }

          dummy[0] ^= nestedBuffer[bufIdxs[base]][bs[base]];
        }

        var after: number = performance.now();
        times[r] = after - before;
      }

      result = median(times);

      if (!i) {
        this.baseline = result;
      } else {
        const factor = 1.5;
        return { median: result, evicts: result >= factor * this.baseline };
      }
    }
  }

  public evicts(bufs: number[][], fast: boolean, __nestedBuffer: number[][]) {
    const reps: number = 8;
    let amp: number = 3;

    if (fast && !this.warm) {
      amp = 6;
      this.warm = true;
    } else if (fast) {
      amp = 1;
    }

    let bufIdxs: number[] = null;

    if (__nestedBuffer) {
      assert(bufs.length === 1);

      bufIdxs = bufs[0];

      if (!this.warm) {
        amp = 6;
        this.warm = true;
      } else {
        amp = 2;
      }
    }

    for (const [i, base] of [0, this.sizeWhenMinimal].entries()) {
      let times: number[] = Array(reps).fill(0);
      let result: number = 0;

      /*
       * Restablish baseline!
       * if (!i && this.baseline) continue;
       */

      /* We need to get this code optimized first */
      for (let r = 0; r < reps; r++) {
        var before: number = performance.now();

        for (let a = 0; a < 4 * 10 ** amp; a++) {
          if (__nestedBuffer) {
            this.evict();

            dummy[0] ^=
              __nestedBuffer[bufIdxs[0]][this.addrs[this.sizeWhenMinimal]];
            dummy[0] ^=
              __nestedBuffer[bufIdxs[1]][this.addrs[this.sizeWhenMinimal + 1]];
          } else if (bufs.length === 2) {
            dummy[0] ^= bufs[0][this.addrs[0]];
            dummy[0] ^= bufs[1][this.addrs[1]];

            for (let i = 2; i < this.sizeWhenMinimal; i++) {
              dummy[0] ^= buf8[this.addrs[i]];
            }

            /* Just one access here: we want to be sure both evict */
            dummy[0] ^= buf8[this.addrs[base]];
          } else {
            this.evict();

            /*
             * These four accesses should be slow (cache misses) if the
             * eviction worked, or fast if we have baseline === true
             */
            dummy[0] ^= buf8[this.addrs[base]];
            dummy[0] ^= buf8[this.addrs[base + 1]];
            /* Also works without them, but less reliably? */
            dummy[0] ^= buf8[this.addrs[base + 2]];
            dummy[0] ^= buf8[this.addrs[base + 3]];
          }
        }

        var after: number = performance.now();
        times[r] = after - before;
      }

      result = median(times);

      if (!i) {
        this.baseline = result;
      } else {
        const factor = 3;

        /* This was a warmup! */
        if (amp === 6) {
          return this.evicts(bufs, fast, __nestedBuffer);
        } else {
          return { median: result, evicts: result >= factor * this.baseline };
        }
      }
    }

    /* Unreachable */
    assert(0);
  }
}
