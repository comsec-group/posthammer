#! /usr/bin/env python3

# Debugging script: writes physical address information into the JavaScript
# buffers

import sys
import time
import random
import os
import subprocess

GB = 2 ** 30
MB = 2 ** 20
KB = 2 ** 10

EXPLOITABLE = 0xFFFE << 48
MODE = "write"  # "write", "view", "flip"
TARGET = "js"  # "firefox", "js"

pid = -1

if TARGET == "js":
    pid = subprocess.run(
        ["pgrep", TARGET], encoding="utf-8", stdout=subprocess.PIPE
    ).stdout.strip()
elif TARGET == "firefox":
    out = (
        subprocess.run(
            ["pgrep", "-f", TARGET], encoding="utf-8", stdout=subprocess.PIPE
        )
        .stdout.strip()
        .split()
    )
    for __pid in out:
        tmp = subprocess.run(
            ["lsof", "-p", __pid],
            encoding="utf-8",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        ).stdout.strip()
        if "file://" in tmp:
            pid = __pid
            break


dbg = open("./maps.dbg.err", mode="w")
dbg.truncate()


def parse_line(line):
    assert len(line) == 5
    line = line[:2]
    base, end = map(lambda x: int(x, 16), line[0].split("-"))
    return [base, end, end - base]


def pfn_get(pagemap, virt):
    pagemap.seek((virt >> 12) * 8)
    entry = int.from_bytes(pagemap.read(8), byteorder="little")
    assert entry & 0x1C00000000000000 == 0x0
    # NOTE: will not fail even if we don't have sudo!
    if entry & 0x8000000000000000 == 0x0:
        # Soft dirty (bit 55) or being removed
        return 0
    else:
        pfn = entry & 0x7FFFFFFFFFFFFF
        assert pfn  # No sudo!?
        return pfn


DEBUG = False


def dbgprint(prev, pfn, string):
    global dbg
    if DEBUG:
        dbgstr = string + " " + str(hex(prev)) + " -> " + str(hex(pfn)) + "\n"
        dbg.write(dbgstr)


def pfn_at_huge_page_boundary(pfn):
    return (pfn << 12) % (2 * MB) == 0


def pfn_at_mb_boundary(pfn):
    return (pfn << 12) % MB == 0


def diststr(pfn, prev):
    if pfn == 0:
        return "0"
    elif prev == 0:
        return "@"
    elif abs(pfn - prev) > 2:
        return "$" if pfn_at_huge_page_boundary(pfn) else "*"
    else:
        # Should not happen, only OK if pfn is zero!
        assert pfn != prev
        return str(abs(pfn - prev))


def get_cont(pagemap, base, end):
    global dbg

    step = 0x1000

    first_pfn = pfn_get(pagemap, base)
    prev = first_pfn

    cont = 1
    max_cont = 0
    max_cont_starts_at_page = 0
    num_big_regions = 0
    num_small_regions = 0
    small_and_aligned = 0
    zero_pages = 0

    #
    # There are only two kinds of OK gaps:
    #
    # A jump: 3 4 * 6 ...
    # A small gap: 3 4 6 7 ...
    #
    # The first is rare though
    #
    near_cont = 1
    near_cont_gaps = 0

    max_near_cont = 0
    max_near_cont_gaps = 0

    viz = ["*"] if prev else ["0"]

    for virt in range(base + step, end, 0x1000):
        pfn = pfn_get(pagemap, virt)

        if pfn == 0:
            zero_pages += 1

        if pfn - prev == 1:
            assert pfn

            cont += 1

            if max(max_cont, cont) == cont:
                max_cont_starts_at_page = (((virt - base) // step) + 1) - cont
                max_cont = cont

            near_cont += 1
            max_near_cont = max(max_near_cont, near_cont)

            if pfn_at_huge_page_boundary(pfn):
                viz.append("!")
            elif pfn_at_mb_boundary(pfn):
                viz.append("m")
            else:
                viz.append("-")
        else:
            if cont >= (10 * MB // (4 * KB)):
                num_big_regions += 1
            if cont >= (2 * MB // (4 * KB)):
                num_small_regions += 1
                # If the new @virt is at a MB, means 2 MB ago we were too
                if (virt >> 0x1000) % MB == 0:
                    small_and_aligned += 1

            assert (pfn == 0 and prev == 0) or pfn - prev != 0

            # Reset
            cont = 1
            dist = diststr(pfn, prev)
            viz.append(dist)

            next_virt = virt + step

            # prev---pfn---next_pfn
            if next_virt < end:
                next_pfn = pfn_get(pagemap, virt)

                # Jump or gap?
                if next_pfn - 2 == prev or not dist in "0@*$":
                    # Saved!
                    near_cont += 1
                    near_cont_gaps += 1
                    max_near_cont = max(max_near_cont, near_cont)
                    max_near_cont_gaps = max(
                        max_near_cont_gaps, near_cont_gaps
                    )
                    prev = pfn
                    continue

            # Reset near cont.
            near_cont = 1
            near_cont_gaps = 0

        prev = pfn

    last_pfn = prev  # Because of prev = pfn

    return (
        end - base,
        zero_pages,
        max_cont,
        max_cont_starts_at_page,
        num_big_regions,
        num_small_regions,
        small_and_aligned,
        max_near_cont,
        max_near_cont_gaps,
        viz,
        first_pfn,
        last_pfn,
    )


f = open("/proc/" + pid + "/maps")
g = open("/proc/" + pid + "/pagemap", mode="rb")
devmem = open("/dev/mem", mode="rb+")
jsdump = open("./dump", mode="r")


def read_phys32(phys, width):
    #  assert phys & 0x3 == 0
    devmem.seek(phys, 0)
    val = int.from_bytes(devmem.read(width), byteorder="little", signed=False)
    return val


def write_phys32(phys, val, width):
    devmem.seek(phys, 0)
    assert (
        devmem.write(val.to_bytes(width, byteorder="little", signed=False))
        == width
    )


INFO = dict()
ALWAYS_REFRESH = False if MODE == "write" else True

idx_most_big = 0
most_big = 0

#
# NOTE: the order will only be correct, chronologically, if every time we pass
# over /proc/pid/maps, we find just one new mapping. If we find more than one,
# they might be added in arbitrary order (prob. based on their base addresses)
#
# We sleep during the last 10 allocs in posthammer.ts to make this work
#
while True:
    active = []
    inactive = []

    candidates = 0
    losers = 0

    f.seek(0)

    for line in f:
        split = line.strip().split()

        if len(split) > 5:
            continue
        elif not "rw" in split[1]:
            continue

        base, end, size = parse_line(split)
        active.append(base)

        if (not base in INFO.keys()) or ALWAYS_REFRESH:
            INFO[base] = get_cont(g, base, end)

    time.sleep(0.5)
    subprocess.run("clear")

    inactive = [base for base in INFO.keys() if not base in active]

    SMALLER_NUM_BUFS = 1
    smaller = [
        base
        for base in INFO.keys()
        # NOTE! INFO[base][1] is the number of zero pages!
        if INFO[base][1] == (SMALLER_NUM_BUFS * 14)
    ]
    last_pfn = 0
    #  shown_one = False

    for idx, base in enumerate(list(INFO.keys()) + inactive):
        if idx < len(INFO.keys()) and base in inactive:
            continue
        elif base in inactive:
            idx = list(INFO.keys()).index(base)

        (
            size,
            zero_pages,
            cont_pages,
            cont_starts_at,
            num_big_regions,
            num_small_regions,
            small_and_aligned,
            max_near_cont,
            max_near_cont_gaps,
            viz,
            my_first_pfn,
            my_last_pfn,
        ) = INFO[base]

        if idx > 0:
            # Only meaningful if ordered!
            viz[0] = diststr(my_first_pfn, last_pfn)

        if max(num_big_regions, most_big) == num_big_regions:
            most_big = num_big_regions
            idx_most_big = idx

        last_pfn = my_last_pfn

        num_pages = size // (4 * KB)
        ratio = max_near_cont / num_pages

        #  if ratio > 0.1 and num_pages > 2:
        #  if ratio > 0.01 and num_pages > 2:
        #  NOTE: play with this while debugging
        if num_pages == 252:
            #  if num_pages == 253:
            #  if True:
            #  if num_pages == 262144:
            #  if num_pages <= 1024:
            if (
                num_pages == 253
                or num_pages == 252
                or num_pages == 262144
                #  and cont_pages >= 2560
                #  and idx == idx_most_big
                #  and False
            ):
                full = "".join(viz)
                if len(full) == 262144:
                    for s in range(0, len(full), 256):
                        sub = full[s : s + 256]
                        print(s // 256, full[s : s + 256])
                elif len(full) == 252 or len(full) == 253:
                    pass
                    #  print(full)

                if base in smaller:
                    STATES = [
                        "check-reuse",
                        "flip-ready",
                        "flip-one",
                        "flip-one-post",
                        "flip-two",
                        "flip-two-post",
                        "flip-three",
                        "flip-three-post",
                    ]

                    if len(smaller) > 1:
                        print(smaller)

                    subprocess.run("clear")
                    print("scanning")
                    state = STATES[0]
                    offsets = []
                    pages = []
                    have_magic = False
                    magic_count = 0
                    inserted_corruption = False

                    while True:
                        small_buf_size = 14 * 4 * KB
                        total = 0

                        # The 2 here comes from the fact that we release the
                        # 3rd buffer! See targetIdx = i + 2 in posthammer.ts
                        for offset in range(
                            2 * small_buf_size,
                            (2 + SMALLER_NUM_BUFS) * small_buf_size,
                            8,
                        ):
                            # Those 14 pages were contiguous, so this works,
                            # even though they may now be all over the place
                            val = read_phys32((my_first_pfn << 12) + offset, 8)
                            page = offset // (4 * KB)

                            if "flip" in state or state == "check-reuse":
                                if have_magic != (val == 0xAAAAAAAAAAAAAAAA):
                                    if state == "check-reuse":
                                        print(magic_count)
                                    magic_count = 0

                                magic_count += 1
                                have_magic = val == 0xAAAAAAAAAAAAAAAA

                                if magic_count == 1 and state == "check-reuse":
                                    print(
                                        page,
                                        offset % 4096,
                                        f"{val:016x}",
                                        end=" ",
                                    )
                                elif state == "check-reuse":
                                    print(f"{val:016x}", end=" ")

                                #  if offset % 64 == 0:
                                #  print(offset, page, f"{val:016x}", end=" ")
                                #  elif offset % 64 == 56:
                                #  print(f"{val:016x}", end="\n")
                                #  else:
                                #  print(f"{val:016x}", end=" ")

                            total += 1

                            #  if "flip" in state and page in pages and val ==

                            if (
                                state == "check-reuse"
                                and val == 0xAAAAAAAAAAAAAAAA
                            ):
                                offsets.append(offset)
                                pages.append(page)
                                #  if not page in pages:
                                #  print("")
                            elif "flip" in state and False:
                                if (
                                    val != 0xAAAAAAAAAAAAAAAA
                                    and random.randint(0, 10) == 0
                                    and offset % 4096 != 0
                                    and not inserted_corruption
                                    and magic_count == 5
                                ):
                                    corrupted = val ^ (
                                        1 << random.randint(0, 63)
                                    )
                                    corrupted = 0
                                    print(
                                        page,
                                        offset % 4096,
                                        "corrupting ",
                                        f"{val:016x}",
                                        "->",
                                        f"{corrupted:016x}",
                                    )
                                    write_phys32(
                                        (my_first_pfn << 12) + offset,
                                        corrupted,
                                        8,
                                    )
                                    inserted_corruption = True
                            elif "flip" in state and offset in offsets:
                                # Get the latest state
                                for line in jsdump:
                                    if "maps" in line.strip():
                                        line = line.strip().split(":")
                                        new = line[1]
                                        mask = int(line[2], 16)
                                        if STATES.index(new) > STATES.index(
                                            state
                                        ):
                                            state = new

                                # 0 means 0 -> 1 and vice versa
                                need_direction = offsets.index(offset)
                                pre = val

                                if (
                                    state == "flip-two"
                                    or state == "flip-three"
                                ) and need_direction == 0:
                                    flip = mask << 48
                                    val = val | flip
                                    direction = "0 -> 1 (forced)"
                                elif (
                                    state == "flip-one" and need_direction == 1
                                ):
                                    flip = mask << 48
                                    direction = (
                                        "0 -> 1"
                                        if (val ^ flip) > val
                                        else "1 -> 0"
                                    )
                                    val = val ^ flip
                                else:
                                    continue  # Wrong offset

                                print(hex(pre), hex(val), direction)
                                write_phys32(
                                    (my_first_pfn << 12) + offset,
                                    val,
                                    8,
                                )

                                print(state, hex(mask))

                                state = STATES[STATES.index(state) + 1]

                                if state == "flip-three-post":
                                    sys.exit(0)

                        count = len(offsets)

                        if state == "check-reuse" and count:
                            print(
                                "result",
                                count,
                                total,
                                round(100 * count / total, ndigits=1),
                            )

                            count = (count / 80) * (80 + 32)

                            print(
                                "with header",
                                count,
                                total,
                                round(100 * count / total, ndigits=1),
                            )

                            num_pages_reused = len(list(set(pages)))
                            assert num_pages_reused <= 14

                            print(
                                "page reuse",
                                num_pages_reused,
                                14,
                                round(100 * num_pages_reused / 14, ndigits=1),
                            )

                            print("moving to flips")
                            state = "flip-ready"
                            time.sleep(1)
                            offsets = [
                                random.choice(offsets),
                                random.choice(offsets),
                            ]
                        elif state == "flip-ready":
                            print("another round...")
                            time.sleep(3)

                #  if num_pages == max_near_cont:
                # New: 16 pages case
                if (
                    num_pages == cont_pages and ("!" in full or "m" in full)
                ) or base in smaller:
                    # Not printing for speed
                    #  pass
                    for s in range(0, len(full), 14):
                        sub = full[s : s + 14]
                        print(s // 14, full[s : s + 14])

                    #  print("candidate (!)")
                    candidates += 1
                    bd = -1

                    if "!" in full:
                        bd = full.index("!")
                    else:
                        bd = full.index("m")

                    print("boundary at", bd)

                    write_phys32((my_first_pfn << 12) + 1, bd, 1)
                    write_phys32((my_first_pfn << 12) + 2, my_first_pfn, 4)

                    cmd = (
                        "sudo busybox devmem "
                        + hex((my_first_pfn << 12) + 1)
                        + " 8 "
                        + str(bd)
                    )
                    print(cmd)
                    #  os.system(cmd)

                    cmd = (
                        "sudo busybox devmem "
                        + hex((my_first_pfn << 12) + 2)
                        + " 32 "
                        + str(my_first_pfn)
                    )
                    print(cmd)
                    #  os.system(cmd)

                else:
                    losers += 1

            print(
                idx,
                (idx // 2) - 20,
                hex(base),
                hex(base + size),
                size // (4 * KB),
                zero_pages,
                str(round(100 * zero_pages / num_pages)),
                "%",
                cont_pages,
                (cont_pages * 4 * KB) / MB,
                "MB @ ",
                cont_starts_at,
                round(cont_starts_at / 256, ndigits=1),  # // 256 to get the MB
                str(num_big_regions) + "B",
                num_small_regions,
                small_and_aligned,
                max_near_cont,
                max_near_cont_gaps,
                str(round(100 * max_near_cont / (size // (4 * KB)), ndigits=1))
                + " %",
                hex(my_first_pfn << 12),
            )

            if (idx // 2) - 20 >= 9000 and MODE == "write":
                sys.exit(0)

    print(
        candidates,
        "candidates and",
        losers,
        "losers",
        str(round(100 * candidates / (candidates + losers + 1))),
        "%",
    )
    print("active", len(active), "inactive", list(map(hex, inactive)))
    print("238", len(smaller), list(map(hex, smaller)))

    if len(smaller) == 1:
        pass
        #  sys.exit(0)
