#! /usr/bin/env python3

# Debugging script: writes physical address information into the JavaScript
# buffers

import sys
import time
import os
import subprocess

GB = 2 ** 30
MB = 2 ** 20
KB = 2 ** 10

pid = subprocess.run(
    ["pgrep", "js"], encoding="utf-8", stdout=subprocess.PIPE
).stdout.strip()

g = open("/proc/" + pid + "/pagemap", mode="rb")
z = open("/dev/mem", mode="rb")

#  cmd = (
#  "sudo busybox devmem "
#  + hex((my_first_pfn << 12) + 1)
#  + " 8 "
#  + str(bd)
#  )
#  print(cmd)
#  os.system(cmd)

BANK_MASKS = [
    0x0000000000002040,
    0x0000000000044000,
    0x0000000000088000,
    0x0000000000110000,
    0x0000000000220000,
]

ROW_MASK = 0x000000003FFC0000
ROW_SHIFT = 18

pfns = []

SLICE_BITS = [
    [
        36,
        35,
        33,
        32,
        30,
        28,
        27,
        26,
        25,
        24,
        22,
        20,
        18,
        17,
        16,
        14,
        12,
        10,
        6,
    ],
    [
        37,
        35,
        34,
        33,
        31,
        29,
        28,
        26,
        24,
        23,
        22,
        21,
        20,
        19,
        17,
        15,
        13,
        11,
        7,
    ],
    [37, 36, 35, 34, 31, 30, 27, 26, 23, 22, 19, 16, 13, 12, 8],
]


def nzb(x):
    return bin(x)[2:].count("1")


def bank_is(addr):
    y = 0

    for i, bm in enumerate(BANK_MASKS):
        y ^= (nzb(bm & addr) % 2) << i
        #  print(i, hex(addr), hex(y))

    #  assert(0)

    return y


def row_is(addr):
    return (addr & ROW_MASK) >> ROW_SHIFT


def sl(addr):
    y = 0
    for i, bits in enumerate(SLICE_BITS):
        y ^= (sum([1 for bit in bits if addr & (1 << bit) != 0]) % 2) << i
    return y


def se(addr):
    return (addr & (0x3FF << 6)) >> 6


with open("pfns.out") as f:
    for line in f:
        pfn = line.strip().split(",")[-1]
        pfn = pfn.split(" ")

        if len(pfn) != 3:
            continue

        pfn = pfn[-1]
        pfns.append(pfn)


pfns = list(map(int, pfns))
entries = dict()

with open("entries.out") as f:
    for i, line in enumerate(f):
        line = line.strip().split(",")

        if i == 0:
            assert line[0] == "esx"
        elif i == 1:
            assert line[0] == "esy"
        else:
            continue

        entries[line[0]] = list(map(int, line[1:]))


pfns = list(set(pfns))


print(len(entries["esx"]))


infos = dict()


def read_phys32(phys):
    assert phys & 0x3 == 0
    z.seek(phys, 0)
    val = int.from_bytes(z.read(4), byteorder="little", signed=False)
    return val


def read_row(phys, expected, add_to_row=0, subtract_from_row=0):
    b = bank_is(phys)

    base = phys & ~((1 << ROW_SHIFT) - 1)
    base += add_to_row << ROW_SHIFT
    base -= subtract_from_row << ROW_SHIFT

    r = row_is(base)

    total = 0
    got = 0

    for offset in range(0, 1 << ROW_SHIFT, 4):
        probe = base + offset

        if bank_is(probe) == b and row_is(probe) == r:
            total += 1
            val = read_phys32(probe)

            if val == expected:
                got += 1
            #  else:

            #  print(offset, hex(val), bank_is(probe), hex(probe), r)

    # -2 for the 32-bit indexing, -1 for the rank bits
    assert total == (2 ** (ROW_SHIFT - 5 - 2))

    return 100 * (got / total)


# Scan these pages for the entries
for pfn in pfns:
    print(pfn)
    for offset in range(0, 1 * MB, 4):
        #  for offset in range(0, 4 * 6, 1):
        phys = (pfn << 12) + offset

        #  cmd = "sudo busybox devmem " + hex((pfn << 12) + offset) + " 32"
        #  value = subprocess.check_output(cmd, shell=True)
        #  value = int.from_bytes(value[2:-1], byteorder="little", signed=False)

        z.seek(phys, 0)
        value = int.from_bytes(z.read(4), byteorder="little", signed=False)

        #  print(offset, hex(value), hex(pfn))

        #  if value != 0xaaaaaaaa and value != 0x0:
        #  print(offset, hex(value))

        if value in entries["esx"] or value in entries["esy"]:
            info = [phys, se(phys), sl(phys), bank_is(phys), row_is(phys)]
            print(
                hex(phys),
                hex(value),
                se(phys),
                sl(phys),
                bank_is(phys),
                row_is(phys),
            )
            infos[value] = info


for i, (x, y) in enumerate(zip(entries["esx"], entries["esy"])):
    for j, __x in enumerate([x, y]):
        phys, st, slc, bk, rw = infos[__x]
        print(
            i,
            hex(phys),
            f"{st:03}",
            f"{slc:1}",
            f"{bk:02}",
            f"{rw:05}",
            read_row(phys, 0x55555555),
            read_row(phys, 0xAAAAAAAA),
        )

        if j == 0:
            print(
                "                      ",
                f"{rw + 1:05}",
                read_row(phys, 0xAAAAAAAA, 1, 0),
            )
            print(
                "                      ",
                f"{rw - 1:05}",
                read_row(phys, 0xAAAAAAAA, 0, 1),
            )
        else:
            print(
                "                      ",
                f"{rw + 1:05}",
                read_row(phys, 0xAAAAAAAA, 1, 0),
            )

    print()
    #  print(infos[x])
    #  print(infos[y])


def pfn_get(pagemap, virt):
    pagemap.seek((virt >> 12) * 8)
    entry = int.from_bytes(pagemap.read(8), byteorder="little")
    assert entry & 0x1C00000000000000 == 0x0
    # NOTE: will not fail even if we don't have sudo!
    if entry & 0x8000000000000000 == 0x0:
        # Soft dirty (bit 55) or being removed
        return 0
    else:
        pfn = entry & 0x7FFFFFFFFFFFFF
        assert pfn  # No sudo!?
        return pfn
